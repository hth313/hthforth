
\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{paralist}
\begin{document}
\title{CalcForth Functional Specification}
\author{Håkan Thörngren}

 \maketitle


\section{Words}
Forth words comes in four flavors,
\begin{inparaenum}[\itshape 1\upshape)]
\item colon definitions;
\item native assembler;
\item lambdas; and
\item colon lambdas.
\end{inparaenum}

Initially, lambdas and colon lambdas are the only words available. Lambdas are really replacements for native words, but implemented on the host side. Colon lambdas are hardcoded colon definitions that execute as normal colon definitions. They are marked as colon lambdas and are meant to be replaced by a real colon (or native) definition.

All lambdas serve as bootstrap code needed before actual definitions can be loaded.

The hosted environment can execute all kind of words except for native assembler. It should prefer colon definitions, then lambdas and finally colon lambdas when executing.

\subsection{Identity}
Each word has a unique identity that is its token. A map from tokens to definitions is used to look up a word. Tokens are stored in colon definitions which allows multiple versions of a word with the same name to coexist.

\subsection{Body}
Words can either be writable or read-only. A body consists of a list of cell elements which are stored in a dlist.
The following cell elements exists:
\begin{enumerate}
\item Forth cell, typically 4 bytes wide.
\item Char (or byte).
\item Various special elements that makes up the header of the word. TBD.
\end{enumerate}

\subsection{Addresses}
Addresses are normally more than just a numeric address. They encode a word using its identity and an offset into they body  that word. It could be tuple {\it (identity, part, offset)\/} where {\it part\/} describes either the header or body.

Address arithmetics need to update the tuple and may change to point into another part!. When finding an element in the body, a linear search is used.\footnote{We do not strive for absolute performance here, the goal is to provide a decent FORTH environment and do cross-compiling to a target. It could be possible to have an address lookup mechanism using a Data.Map to speed things up later. Such Data.Map need only to contain the valid addresses for the word.}

Incorrect addressing will cause an abort condition. The rationale is that we do not really specify the byte order and such ``tricks'' are illegal in the initial implementation.

\section{Dictionary}
The dictionary is implemented as a linked list just as an ordinary Forth dictionary. This means linear search for a name in the dictionary. This allows multiple vocabularies and ability to forget words.

\section{FORTH source}
FORTH source code is either implemented as FORTH screens or ordinary named files. For bootstrap purposes, a named file is enough as it allows flexible management of the source code on the rather large source screens available on modern computers. A means of loading named files should exist. Reading source files is only supported by the hosted environment.



\end{document}
