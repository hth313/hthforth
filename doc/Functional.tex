\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{paralist}
\begin{document}
\title{CalcForth Functional Specification}
\author{Håkan Thörngren}

 \newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf+}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}

 \maketitle

\section{Introduction}
CalcForth is meant to be a replacement environment for the ARM based HP calculators like the HP-12C+ and HP-30b. As the name implies, it is a Forth based environment.

\subsection{Background}
Traditionally, calculators were implemented in assembler back in the old days, as memory resources were scarce and performance was low. Every little bit of power had to be squeezed into these small handheld devices. Today off-the-shelf 32-bit RISC processors are used and manufacturers such as HP has seen an opportunity in providing ways to re-program the devices. Simply put, with a little bit of extra effort on the manufacturer side, the product can be used for other purposes. Thus increasing interest in the product and extra sales in the end.

Thanks to tremendous processing power available in 32-bit RISC devices, there is no longer a need to program the calculators in assembler, but rather C or even Embedded \CC{} is used. In some cases, like the HP-12C+, the software is actually an emulator for the vintage hardware complete with the original ROM image.

\subsection{Forth}
Forth had its heyday in the early eighties when microcomputers were far less powerful than today.
Today Forth has its followers, but they are rather few. Forth is still an appealing choice for a small interactive environment. An alternative language could be Scheme, but for this project Forth was chosen for the following reasons:
\begin{enumerate}
\item Forth is not a language to write programs in, it is a language that is extended to suit the problem.
\item Forth comes with an interactive environment, well suited for experimenting and playing with, rather than just running a ready made program.  This fits better with how an advanced calculator is best used.
\item Ability to record simple user programs comes more or less free with the language. Larger programs are also possible, but as mentioned, are more likely to be implemented as smaller building blocks to help solving the problems at hand.
\item There is no gap between the built-in functionality and what the end user adds to it. Such gaps are common in most calculators that are implemented in a different language than what is provided to the user.
\item Small footprint and good performance.
\item High coolness factor and hopefully also lots of fun.
\end{enumerate}

\section{User Experience}
A calculator is an ``instant on device'', meaning you do not need to wait for it to start. The calculator will be ready to use within a fraction of a second after pressing the ON key. Calculators also use specialized keyboards, where often used functions are available at single key presses. Extensions to this scheme are often also provided by the use of shift keys or secondary key presses to provide more functions easy at hand. This in contrast to a traditional keyboard where you need to spell out longer sequences to form commands.

Forth itself relies on a traditional keyboard, not a calculator style keyboard. Another problem is that a traditional keyboard may not even be available. Since Forth is a language that is meant to be extended, a calculator style keyboard handling is one of the extensions to be provided and this will act as the input interface when activated.

It may still be desirable to hit the low level Forth engine from a traditional alphanumeric keyboard and this will be made possible as a another keyboard mode. In reality, the calculator hardware may be more or less ill suited for this, providing too few keys, no alphanumeric keyboard labeling or even a display that can show alpha characters. Thus, while it may be more or less possible to provide a Forth low level command line mode, the user experience may suffer quite a bit depending on the hardware at hand.

\subsection{Host Mode}
Since the hardware is expected to more or less severely limited, a host computer is meant to be used for development. This will allow for disk I/O (loading Forth source), building flash images and playing with the hardware using a real alphanumeric keyboard. In addition to Forth screens, Forth stream files are also supported

The host mode is only needed for development. In daily use CalcForth will act as a standalone environment on the calculator hardware. Adding smaller programs (definitions) shall be possible on the standalone calculator.

A cable of some kind will be needed, it can be a serial cable, USB or JTAG that will allow the host to talk to the calculator to provide the following use cases:
\begin{itemize}
\item Use the host as a Forth terminal.
\item Load source code from disk. Definitions are written to CalcForth RAM for immediate availability, commands are executed on hardware.
\item Make CalcForth images and flash the calculator.
\end{itemize}

\subsubsection{Forth Screens}
This is the traditional way of handling Forth source code.
Multiple screens are kept in a disk. A disk will correspond to a file on the host. Inside a disk, multiple Forth screens are stored using Forth mode in Emacs, which uses narrowing to display a screen at a time.

\subsubsection{Forth Stream Files}
As an alternative to Forth screens, Forth stream files are supported. They are just plain source files with Forth source code, without line length or file length limitations.

Forth stream files work quite nicely with the modular word set approach used by the Forth 200x standard, a word set has a name and is just a correspondingly named source file.

\subsection{Calculator Shell}
CalcForth provides several shells of which one can be the active one. The shell affects the keyboard and the default display.

A scientific shell can provide suitable scientific functions on the keys and display the floating point number on top of the floating point stack. Another shell could be a business shell, which provides a different keyboard and a display routine that displays numbers in a more suitable way for monetary values.

It is worth noting that the shell does not change any of the inner working of the calculator in any way, only  the user interface. Thus, it is perfectly possible to perform business functions when in scientific mode.

The following list gives some ideas on possible shells, but does not indicate that they must be implemented:
\begin{description}
\item[Scientific] gives floating point numbers, trigonometric, logarithmic and many other functions.
\item[Complex] similar to Scientific, but works on complex numbers.
\item[Business] works with time, interest rates and monetary values using floating point numbers.\footnote{Business could perhaps be implemented using fixed point numbers on the ordinary Forth stack. The disadvantage would be that it behave quite differently compared to the other modes.}
\item[Programmer] provides an integer mode user settable word size, sign mode, microprocessor style flags and arithmetic logic functions. Much like an HP-16C.
\item[Forth] provides an alphanumeric keyboard and access to the Forth command line.
\end{description}

In addition to these, the user can create shells (or application shells) by basing it on an existing shell or define a new from scratch. Though doing so will most likely require using the host mode.

\subsubsection{Talking Keys}
Since keys change behavior there need to be a way to find out what a key does without actually performing its action. The ``talking keys'' feature is borrowed from the HP-41. When you press a key, the function it will perform will be displayed and if you keep the key pressed, the action will be NULLed.

An alternative, or perhaps complement to the talking key approach is to have dynamic overlays. That is however not an easy feat on a traditional calculator, but could be a possibility on a hardware based on E-ink, a smartphone or a tablet.

\subsubsection{User Mode Customization}
In addition to provide pre-defined shells, the end user can customize the keyboard by assigning a different function to a key. The re-assigned functions are available in User mode which can be toggled on and off.

There are two levels of User mode key assignments,
\begin{inparaenum}[\itshape a\upshape)]
\item global which affects all shells;  and
\item local shell specific ones.
\end{inparaenum}


\section{Stacks}
Forth is a stack based language. The ordinary Forth stacks are available in CalcForth and the word size used is 32 bits. A double word is therefore 64 bits long.

In addition to this, there is an RPN stack that is 4 levels deep with LastX register and stack lift flag.
Each register occupies 2 times 64 bits, which allows for 64-bit IEEE complex numbers and up to 128-bit integers.
This stack can be operated in three modes,
\begin{inparaenum}[\itshape a\upshape)]
\item  floating point mode,
\item complex mode; and
\item integer mode with the defined word size.
\end{inparaenum}

The upper 64-bits holds the imaginary part. A complex number on the stack will survive changing to a different stack mode and back provided that the number is not affected by operations.\footnote{Meaning that a number that is just on the stack will not get busted in a different mode unless the lower part is altered}

When going between stack modes, numbers on the stack may change meaning depending on the mode and no special conversions take place. This make it possible to switch to integer mode to manipulate IEEE floating point numbers at bit level.

The rationale here is that while the RPN stack is kind of short, it is well thought out and familiar to many people. The advantage of a longer stack with Forth semantics would be allow for keeping a record of previous calculations, but that works better if the display is multilevel, something we do not expect to have. The limitation of the short stack can be compensated by using the other Forth stacks as a temporary storage area for RPN stack values.\footnote{This could be a mechanism similar to {\tt R>} and {\tt >R} that Forth programmer have abused with great success to ease the pressure on the data stack.}

On the other hand, once you get used to having a virtually unlimited stack, the 4-level RPN stack becomes a severe limitation. The Forth 200x standard comes with an alternative floating point stack that shall be at least 6 items, which of course easily can be configured to be something more reasonable large. Using that stack for the calculator values is tempting and solves the problem of the too small RPN stack. On the other hand, it does not address the LastX register which gives a way of undoing an undesired operation.\footnote{While it is useful up to a point, it is not the most user friendly way of recovering from a disaster, a proper undo would be more user friendly.}

It remains to be decided which user value stack to provide, either a traditional RPN stack or a larger stack and losing some of the nifty special features of the RPN stack, but then solving the most glaring problem with the RPN stack.

\subsection{Overflows and Underflows}
Forth stack overflows and underflows are detected and if they occur, execution is aborted.  The RPN stack can neither overflow or underflow by design.

\section{Non-Goals}
The following are issues that are {\it not\/} to be solved by CalcForth:
\begin{itemize}
\item The problem of how the keys and keyboard are labeled is not addressed at all. This result is that the end product may be far from the most user friendly calculator you have used.
\item CalcForth will not provide arbitrary I/O to the world except for the host mode. Though, it is quite possible to write such extensions if the hardware is available.\footnote{Sadly, such hardware tend not to be available these days.}
\item Arbitrary precision numbers will not be supported.
\item Text capabilities are to be handled at Forth level. This is not meant to be a seamless alphanumeric calculator.\footnote{This may be a future extension. An alpha register like on the HP-41 could make sense.}
\item Symbolic math is not supported.
\item Units, such as unit tagged numbers or conversions are not supported.\footnote{This is also a very nice feature and could be a future extension. However, the problem with putting a unit on numbers is that you are essentially tagging numbers and the basic idea here is to work with untagged numbers. Otherwise we may end up with something similar to RPL and the HP-48, and that is definitely a non-goal. However, if implemented in scientific mode, the unused upper part could serve as the unit tag.}
\item No specific means to capture runaway programs are defined.
\end{itemize}


\end{document}
